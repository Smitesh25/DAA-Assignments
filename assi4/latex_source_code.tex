\documentclass[12pt,a4paper]{article}
\usepackage[latin2]{inputenc}
\usepackage{graphicx}
\usepackage{ulem}
\usepackage{amsmath}
\usepackage{multicol}
\begin{document}
\begin{center}DAA432C Group-30 Assignment-04\end{center}

\begin{center}\textit{B. Tech IT 4$^{th}$ Semester Sec-A}
\end{center}

\begin{center}\textit{Indian Institute of Information Technology, 
Allahabad}\end{center}


\begin{multicols}{3}
\begin{center}IIT2019092\end{center}

\begin{center}Tanish Patel\end{center}

\begin{center}iit2019092@iiita.ac.in\end{center}

\begin{center}IIT2019090\end{center}

\begin{center}Smitesh Hadape\end{center}

\begin{center}iit2019090@iiita.ac.in\end{center}

\begin{center}IIT2019091\end{center}

\begin{center}Varun Bhardwaj\end{center}

\begin{center}iit2019091@iiita.ac.in\end{center}
\end{multicols}



\begin{multicols}{2}
\textbf{\textit{Abstract--- }In this report, the design and analysis of an algorithm that finds the missing element in an array that represents elements of an arithmetic progression in order using divide and conquer approach.}

\textbf{\textit{Keywords--- }Divide and conquer approach, arithmetic progression, array }

\begin{center}I. INTRODUCTION\end{center}

This paper discusses about an algorithm that is  designed to  find the missing element in an array that represents elements of an arithmetic progression in order using divide and conquer approach. Arithmetic Progression (AP) is a sequence of numbers in order in which the difference of any two consecutive numbers is a constant value. 

\ \ \ \ Since the elements of an array represent an arithmetic progression, the array is already sorted either in increasing or decreasing order.  We have also analysed about the time and 
space complexities of the algorithm.  

By the end of the paper, we will be able to understand the components of 
algorithm design and will learn different ways of analysing the 
algorithms. 

\begin{center}II. ALGORITHM DESIGN\end{center}

\ \ \ \ The given problem can be solved using divide and conquer approach which is similar to binary search.Basically we divide the given problem into smaller sub-problems and appropriately combine their solutions to get the solution to the main problem.  


\textit{  Approach:}The idea is to keep on checking the difference between the middle element and its adjacent elements unless the difference is not equal to the desired common difference.


\textit{  Algorithm:}

\newcounter{numberedCntA}
\begin{enumerate}
\item Find the mid element of the array and initialise an answer variable as the smallest integer that can be stored.
\item Check the difference between the middle element and its previous element. If the difference is not equal to the common difference of the AP, then store the missing number in an answer variable and make no further calls to the function, else proceed to next step.
\item Check the difference between the middle element and its next element. If the difference is not equal to the common difference of the AP, then store the missing number in a variable and make no further calls to the function, else proceed to next step.
\item If the current element is at its correct position, then divide the array into 2 halves, and perform the above steps in the later half, i.e. in the sub array from mid+1 till the end.
\item If the current element is not at its correct position, then divide the array into 2 halves, and perform the above steps in the first half, i.e. in the sub array from starting element till the mid.
\item After performing all the steps for all the subproblems, if the value of the answer variable is unchanged, then no element is missing in the array, otherwise, print the value of the answer variable.
\setcounter{numberedCntA}{\theenumi}
\end{enumerate}




\begin{center}III. PSEUDO CODE\end{center}

\textit{ Declare global variable ans=INT\_MIN}

Function missingTerm(Argument a$[$$]$, Argument l, Argument h, Argument d) 


\{ 

\quad  If l is greater than or equal to h 

\quad\quad return ; 



\quad initialize m = (l + h) / 2

\quad initialize current=a$[0]$+m*d



\quad If a$[m]$-a$[m-1]$ is not equal to d and m is greater than 0

\quad\quad ans=a$[m-1]$+d 


\quad Else if a$[m+1]$-a$[m]$ is not equal to d and m+1 is less than h 

 \quad\quad ans=a$[m]$+d 
 
 \quad Else if a$[m]$ is equal to current
 
 \quad\quad missingTerm(a, m+1, h, d)
 
 \quad Else 
 
 \quad\quad missingTerm(a. l, m-1, d)

 

\quad return ; 

end

\} 

\ \ Main function()\{ 

\quad Initialize integer array arr$[$$]$

\quad  Initialize n as size of array

\quad Input the elements of the array 

\quad If n is less than 3, print "invalid input"

\quad Else \{

\quad Initialize d

\quad If a$[2]$-a$[1]$ is equal to a$[1]$-a$[0]$

\quad \quad d=a$[1]$-a$[0]$

\quad Else if a$[3]$-a$[2]$ is equal to a$[2]$-a$[1]$

\quad \quad d=a$[2]$-a$[1]$

\quad Else 

\quad \quad d=a$[1]$-a$[0]$

\quad missingTerm(a, 0, n, d)

\quad If ans is greater than INT\_MIN

\quad \quad print ans

\quad If ans is greater than INT\_MIN

\quad \quad print No term is missing

\}



\} 


\begin{center}IV. ALGORITHM ANALYSIS\end{center}


\ \ For the above approach based on divide and conquer we are effectively dividing the array in the array into 2 halves each time, until the missing element is found.
 

\textit{ Calculating time complexity: }Assume that k the function missingTerm is called k times. 

- At each function call, the array is divided into 2 halves. Assume the length of the array before any function calls is n.

- After the 1st function call, length of array becomes n/2.

-  After the 2nd function call, length of array becomes n/4.

-  After the 3rd function call, length of array becomes n/8.

-  After the kth function call, length of array becomes n/2$^{k}$.

-  Since the length of the array becomes 1 after k function calls(worst case) 

=$>$ n = 2$^{k}$

Hence k = log$_{2}$ (n)



Hence, the time complexity for the above approach is log$_{2}$
(n).

\textbf{Best Case }

The best case arises when the element at the middle of the array is missing, i.e. the element at the middle position is not at the appropriate position in the AP. In this case, there are no function calls involved and hence the time complexity would be O(1).


\end{multicols}
\begin{center}TABLE 2\end{center}

\begin{center}TIME COMPLEXITY OF BINARY SEARCH APPROACH\end{center}

\begin{table}[h]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Class} & \textbf{Time} \\
\hline
Worst case Complexity & O(log n) \\
\hline
Best Case Complexity & O(1) \\
\hline
\end{tabular}
\end{table}

\begin{multicols}{2}
No extra space is required for any additional array or such so the space 
complexity will be constant.

Space Complexity: O(1)



\begin{center}VI. PROFILING\end{center}



\textit{A. Time Complexity and Space Complexity:}

\ \ \ \ In this section, the  \textit{Posteriori Analysis or Profiling has been discussed. }
Now let us have the glimpse of time graph and then have a glimpse of the space graph.
\end{multicols}
\begin{figure}[h]
\centering
\includegraphics[width=8.44cm,height=6.64cm]{tc.png}
\end{figure}

\begin{multicols}{2}
\begin{center}Figure 1: Time Complexity\end{center}


\end{multicols}
\begin{figure}[h]
\centering
\includegraphics[width=8.44cm,height=6.73cm]{sc.png}
\end{figure}

\begin{multicols}{2}
\begin{center}Figure 2: Space Complexity\end{center}





\begin{center}VII. CONCLUSION\end{center}

\ \ \ \ We can conclude that the above algorithm has the least time and space 
complexity to find the missing element in an array that represents elements of an arithmetic progression in order.


\begin{center}REFERENCES\end{center}

$[$1$]$ Introduction to Algorithms / Thomas H. Cormen \ldots $[$et 
al.$]$. - 3$^{rd}$ edition.

$[$2$]$ The Design and Analysis of Algorithms (Pearson) by A V Aho, J E 
Hopcroft, and J D Ullman 

$[$3$]$ Algorithm Design (Pearson) by J Kleinberg, and E Tard

$[$4$]$ https://www.geeksforgeeks.org/find-missing-number-arithmetic-progression/

\end{multicols}







\end{document}
